<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NSG_SpatialReferenceSystemsTests.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">NSG GeoPackage 1.1 Conformance Test Suite</a> &gt; <a href="index.source.html" class="el_package">org.opengis.cite.gpkg12.nsg.core</a> &gt; <span class="el_source">NSG_SpatialReferenceSystemsTests.java</span></div><h1>NSG_SpatialReferenceSystemsTests.java</h1><pre class="source lang-java linenums">package org.opengis.cite.gpkg12.nsg.core;

import static org.testng.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import org.opengis.cite.gpkg12.CommonFixture;
import org.opengis.cite.gpkg12.nsg.util.CrsList;
import org.opengis.cite.gpkg12.nsg.util.CrsListingUtils;
import org.opengis.cite.gpkg12.util.DatabaseUtility;

import org.testng.Assert;
import org.testng.SkipException;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;


import org.geotoolkit.factory.FactoryFinder;	 // Do NOT import the org.geotools.referencing.ReferencingFactoryFinder
import org.opengis.referencing.crs.CRSFactory;
import org.opengis.referencing.crs.CoordinateReferenceSystem;
import org.opengis.referencing.cs.AxisDirection;
import org.opengis.util.FactoryException;
//import org.opengis.referencing.operation.CoordinateOperation;
//import org.opengis.referencing.operation.CoordinateOperationFactory;


<span class="fc" id="L43">public class NSG_SpatialReferenceSystemsTests extends CommonFixture {</span>

<span class="fc" id="L45">    private final static Logger LOG = Logger.getLogger( NSG_SpatialReferenceSystemsTests.class.getName() );</span>

    private static final String ANNEX_C_3395_TABLE = &quot;Annex_C_3395_Table.txt&quot;;

    private static final String ANNEX_E_4326_TABLE = &quot;Annex_E_4326_Table.txt&quot;;

    private static final double TOLERANCE = 1.0e-10;

    private CrsList crsListing;

    /** Factory to create coordinate reference systems */
<span class="fc" id="L56">    private CRSFactory crsFactory = org.geotoolkit.factory.FactoryFinder.getCRSFactory(null);  // we are calling it out specifically here due to conflicts with other packages.</span>
    

    @BeforeClass
    public void parseCrsListing() {
<span class="nc" id="L61">        crsListing = CrsListingUtils.parseCrsListing();</span>
<span class="nc" id="L62">    }</span>

    /**
     * NSG Req 3: The CRSs listed in Table 4, Table 5, and Table 6 SHALL be the only CRSs used by raster tile pyramid
     * and vector feature data tables in a GeoPackage.
     *
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 3 (identified CRSs)&quot;)
    public void crsTest()
                            throws SQLException {
<span class="nc bnc" id="L74" title="All 2 branches missed.">        if ( crsListing == null )</span>
<span class="nc" id="L75">            throw new SkipException( &quot;No designated CRS Lookup Table available&quot; );</span>

<span class="nc" id="L77">        String queryStr = &quot;SELECT srs_id, organization_coordsys_id FROM gpkg_spatial_ref_sys&quot;;</span>

<span class="nc" id="L79">        try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L80">                                final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L81">            final Collection&lt;String&gt; invalidSrsIds = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L82">            final Collection&lt;String&gt; invalidOrgIds = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L84" title="All 2 branches missed.">            while ( resultSet.next() ) {</span>
<span class="nc" id="L85">                String srsID = resultSet.getString( &quot;srs_id&quot; ).trim();</span>
<span class="nc" id="L86">                String orgID = resultSet.getString( &quot;organization_coordsys_id&quot; ).trim();</span>

<span class="nc bnc" id="L88" title="All 4 branches missed.">                if ( srsID.equals( &quot;0&quot; ) || orgID.equals( &quot;0&quot; ) ) {</span>
<span class="nc" id="L89">                    continue;</span>
                }
<span class="nc bnc" id="L91" title="All 4 branches missed.">                if ( srsID.equals( &quot;-1&quot; ) || orgID.equals( &quot;-1&quot; ) ) {</span>
<span class="nc" id="L92">                    continue;</span>
                }

<span class="nc" id="L95">                String crsOrgID = crsListing.getOrganizationCoordsysIdBySrsId( srsID );</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                if ( crsOrgID == null ) {</span>
<span class="nc" id="L97">                    invalidSrsIds.add( srsID );</span>
                } else {
<span class="nc bnc" id="L99" title="All 2 branches missed.">                    if ( !crsOrgID.equals( orgID ) ) {</span>
<span class="nc" id="L100">                        invalidOrgIds.add( orgID );</span>
                    }
                }
<span class="nc" id="L103">            }</span>
<span class="nc" id="L104">            resultSet.close();</span>
<span class="nc" id="L105">            statement.close();</span>

<span class="nc" id="L107">            assertTrue( invalidSrsIds.isEmpty(),</span>
<span class="nc" id="L108">                        MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid srs_id values {0}&quot;,</span>
<span class="nc" id="L109">                                              invalidSrsIds.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc" id="L110">            assertTrue( invalidOrgIds.isEmpty(),</span>
<span class="nc" id="L111">                        MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid organization_coordsys_id values {0}&quot;,</span>
<span class="nc" id="L112">                                              invalidOrgIds.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc bnc" id="L113" title="All 16 branches missed.">        }</span>
<span class="nc" id="L114">    }</span>

    /**
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 4 &amp; 5 (match Annex table)&quot;)
    public void matchAnnexTableTest()
                            throws SQLException {
        // --- original intent was to implement here; but may make more sense to
        // implement in NSG_TileTests
<span class="nc" id="L125">        final Collection&lt;String&gt; invalidMatrixEntries = new LinkedList&lt;&gt;();</span>

        // In the case there is no gpkg_tile_matrix ... say this geopackage has no tiles, skip this test
<span class="nc" id="L128">        final boolean hasTileMatrixTable = DatabaseUtility.doesTableOrViewExist( this.databaseConnection,</span>
                                                                                 &quot;gpkg_tile_matrix&quot; );

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if ( hasTileMatrixTable ) {</span>

<span class="nc" id="L133">            String queryStr = &quot;SELECT tm.table_name AS tabName, sel.data_type AS dataTyp, sel.crs_id AS crsID, tm.zoom_level AS zoomLvl, tm.matrix_width AS matrixW, tm.matrix_height AS matrixH, tm.tile_width AS tileW, tm.tile_height AS tileH, tm.pixel_x_size AS pixelSzX, tm.pixel_y_size AS pixelSzY &quot;</span>
                              + &quot;FROM gpkg_tile_matrix tm &quot;
                              + &quot;INNER JOIN (SELECT gc.table_name, gc.data_type, gs.organization_coordsys_id as crs_id  from gpkg_contents gc inner join gpkg_spatial_ref_sys gs where gc.srs_id=gs.srs_id) AS sel &quot;
                              + &quot;ON tm.table_name=sel.table_name &quot; + &quot;WHERE crsID IN (3395, 4326) ORDER BY zoomLvl;&quot;;

<span class="nc" id="L138">            try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L139">                                    final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L140">                List&lt;Object[]&gt; annexC_3395 = populateAnnex( ANNEX_C_3395_TABLE, &quot;Annex C (EPSG:3395)&quot; );</span>
<span class="nc" id="L141">                List&lt;Object[]&gt; annexE_4326 = populateAnnex( ANNEX_E_4326_TABLE, &quot;Annex E (EPSG:4326)&quot; );</span>

<span class="nc bnc" id="L143" title="All 2 branches missed.">                while ( resultSet.next() ) {</span>
<span class="nc" id="L144">                    String tabNam = resultSet.getString( &quot;tabName&quot; ).trim();</span>
<span class="nc" id="L145">                    String srsID = resultSet.getString( &quot;crsID&quot; ).trim();</span>
<span class="nc" id="L146">                    int zoomLvl = resultSet.getInt( &quot;zoomLvl&quot; );</span>

<span class="nc" id="L148">                    long matrixW = resultSet.getLong( &quot;matrixW&quot; );</span>
<span class="nc" id="L149">                    long matrixH = resultSet.getLong( &quot;matrixH&quot; );</span>
<span class="nc" id="L150">                    double pixelSzX = resultSet.getDouble( &quot;pixelSzX&quot; );</span>
<span class="nc" id="L151">                    double pixelSzY = resultSet.getDouble( &quot;pixelSzY&quot; );</span>

<span class="nc" id="L153">                    List&lt;Object[]&gt; annexTable = selectAnnexBySrsId( srsID, annexC_3395, annexE_4326 );</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                    for ( Object[] obj : annexTable ) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                        if ( zoomLvl == (int) obj[0] ) {</span>
<span class="nc" id="L156">                            long imW = (long) obj[3];</span>
<span class="nc" id="L157">                            long imH = (long) obj[4];</span>
<span class="nc" id="L158">                            double pX = (double) obj[2];</span>
<span class="nc" id="L159">                            double pY = (double) obj[2];</span>

<span class="nc bnc" id="L161" title="All 2 branches missed.">                            if ( Math.abs( pX - pixelSzX ) &gt; TOLERANCE ) {</span>
<span class="nc" id="L162">                                invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
                                                          + &quot;Pixel Size X: &quot; + pixelSzX + &quot;; but expected &quot; + pX );
<span class="nc bnc" id="L164" title="All 2 branches missed.">                            } else if ( Math.abs( pY - pixelSzY ) &gt; TOLERANCE ) {</span>
<span class="nc" id="L165">                                invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
                                                          + &quot;Pixel Size Y: &quot; + pixelSzY + &quot;; but expected &quot; + pY );
<span class="nc bnc" id="L167" title="All 2 branches missed.">                            } else if ( imW != matrixW ) {</span>
<span class="nc" id="L168">                                invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
                                                          + &quot;Matrix Width: &quot; + matrixW + &quot;; but expected &quot; + imW );
<span class="nc bnc" id="L170" title="All 2 branches missed.">                            } else if ( imH != matrixH ) {</span>
<span class="nc" id="L171">                                invalidMatrixEntries.add( tabNam + &quot; (&quot; + srsID + &quot;, Zoom Level: &quot; + zoomLvl + &quot;): &quot;</span>
                                                          + &quot;Matrix Height: &quot; + matrixH + &quot;; but expected &quot; + imH );
                            }
                        }
<span class="nc" id="L175">                    }</span>
<span class="nc" id="L176">                }</span>
<span class="nc" id="L177">                assertTrue( invalidMatrixEntries.isEmpty(),</span>
<span class="nc" id="L178">                            MessageFormat.format( &quot;The gpkg_tile_matrix table contains invalid Pixels Size or Matrix Size values for tables: {0}&quot;,</span>
<span class="nc" id="L179">                                                  invalidMatrixEntries.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc bnc" id="L180" title="All 16 branches missed.">            }</span>
        }
<span class="nc" id="L182">    }</span>

    /*
     * TODO: Implement Test for Requirement 6
     * 
     * --- NSG Req 6: The WGS 84 Geographic 2D CRS SHALL be used for 2D vector features. WGS 84 Geographic 2D
     * GeoPackages SHALL follow the technical guidance provided in Annex E: Implementation Guide for EPSG::4326 Tiles.
     * 
     * @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 6 (match Annex table)&quot;)
     */

    /**
     * NSG Req 8: The CRS definitions in Table 7 through Table 19 below SHALL be used to specify the CRS used for tiles
     * and vector feature user data tables containing NSG data in a GeoPackage.
     *
     * NSG Req 9: Other CRS definitions SHALL NOT be specified for GeoPackage SQL tables containing NSG data.
     *
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 8 &amp; 9 (CRS definitions)&quot;)
    public void crsDefinitionsTest()
                            throws SQLException {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if ( crsListing == null )</span>
<span class="nc" id="L206">            throw new SkipException( &quot;No designated CRS Lookup Table available&quot; );</span>

<span class="nc" id="L208">        String queryStr = &quot;SELECT srs_id,definition FROM gpkg_spatial_ref_sys&quot;;</span>

<span class="nc" id="L210">        try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L211">                                final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L212">            final Collection&lt;String&gt; invalidSrsDefs = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">            while ( resultSet.next() ) {</span>
<span class="nc" id="L215">                String srsID = resultSet.getString( &quot;srs_id&quot; ).trim();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                if ( srsID.equals( &quot;0&quot; ) ) {</span>
<span class="nc" id="L217">                    continue;</span>
                }
<span class="nc bnc" id="L219" title="All 2 branches missed.">                if ( srsID.equals( &quot;-1&quot; ) ) {</span>
<span class="nc" id="L220">                    continue;</span>
                }

                
                // Get the current CRS definition and get from our saved specification,
                // the CRS definition that we expect. Both of these are WKT.
<span class="nc" id="L226">                final String defin = resultSet.getString( &quot;definition&quot; );</span>
<span class="nc" id="L227">                final String specin = crsListing.getDefinitionBySrsId( srsID );</span>

<span class="nc" id="L229">            	boolean crsEquivalent = false;</span>
<span class="nc" id="L230">            	boolean parseFailure = false;</span>
            	
<span class="nc" id="L232">            	CoordinateReferenceSystem testCRS = null;</span>
<span class="nc" id="L233">            	CoordinateReferenceSystem specCRS = null;</span>

    			// Parse WKT - this one is from the specification file
    			try {
<span class="nc" id="L237">    				specCRS = crsFactory.createFromWKT(specin);</span>
<span class="nc" id="L238">    			} catch (FactoryException e) {</span>
<span class="nc" id="L239">    				parseFailure = true;</span>
<span class="nc" id="L240">    				final String issueRpt = String.format(&quot; Specification CRS WKT parse failure. WKT: %s : Failure Message : %s&quot;,</span>
<span class="nc" id="L241">    						specin, e.getMessage());</span>
<span class="nc" id="L242">                    invalidSrsDefs.add( issueRpt);</span>
<span class="nc" id="L243">                    LOG.log( Level.WARNING,</span>
                    		issueRpt,
<span class="nc" id="L245">                             invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) );  </span>
    				//e.printStackTrace();
<span class="nc" id="L247">    			}</span>
    			// Parse the WKT - this one is from the geopackage
    			try {
<span class="nc" id="L250">    				testCRS = crsFactory.createFromWKT(defin);</span>
<span class="nc" id="L251">    			} catch (FactoryException e) {</span>
<span class="nc" id="L252">    				parseFailure = true;</span>
<span class="nc" id="L253">    				final String issueRpt = String.format(&quot; GeoPackage CRS WKT parse failure. WKT: %s : Failure Message : %s&quot;,</span>
<span class="nc" id="L254">    						defin, e.getMessage());</span>
<span class="nc" id="L255">                    invalidSrsDefs.add( issueRpt);</span>
<span class="nc" id="L256">                    LOG.log( Level.WARNING,</span>
                    		issueRpt,
<span class="nc" id="L258">                             invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) );        			</span>
    				//e.printStackTrace();
<span class="nc" id="L260">    			}</span>


        		// If they were actually both set, put them back out to WKT and now compare them
        		// They should be mostly normalized now - However, there still may be spaces
        		// in there that could cause a difference. Hence, we'll compare using a function that
        		// strips spaces and moves all content to lower case.
    			// This is still an extremely incomplete test and the CRSs may still be the same. In part,
    			// this is due to different variations of WKT content.
    			// We have found no WKT comparison utilities that will work.
<span class="nc bnc" id="L270" title="All 4 branches missed.">        		if (testCRS != null &amp;&amp; specCRS != null) {</span>
        			
<span class="nc" id="L272">        			crsEquivalent  = compareDefintion( testCRS.toWKT(), specCRS.toWKT() );</span>
        			
        			// At this point we know the names from testCRS.getName() may still be different,
        			// and the identifiers from testCRS.getIdentifiers() may be different, but these
        			// may still be &quot;the same&quot; CRS. There is not much we can do about it given the available
        			// utilities.
       			
        		}
                
        		// First type of failure is the failure to even parse the CRS WKT
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (parseFailure) {</span>
<span class="nc" id="L283">                	final String issueRpt = String.format(&quot;srs_id: %s : GeoPackage WKT: %s : Specification WKT: %s &quot;, </span>
                			srsID, defin, specin);
<span class="nc" id="L285">            		invalidSrsDefs.add( issueRpt );</span>
<span class="nc" id="L286">                    Assert.fail( MessageFormat.format( &quot;The CRS for srs_id is not equivalent to the specification due to failure in parsing the WKT.  {0}&quot;,</span>
<span class="nc" id="L287">                            invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );                    	</span>
                }
                // Next type of failure is if the test to see if the parsed WKTs are equivalent or not
<span class="nc bnc" id="L290" title="All 2 branches missed.">            	if (!crsEquivalent) {</span>
<span class="nc" id="L291">                	final String issueRpt = String.format(&quot;srs_id: %s : GeoPackage WKT (normalized): %s : Specification WKT (normalized): %s &quot;, </span>
<span class="nc" id="L292">                			srsID, testCRS.toWKT(), specCRS.toWKT());</span>
<span class="nc" id="L293">            		invalidSrsDefs.add( issueRpt );</span>
<span class="nc" id="L294">                    Assert.fail( MessageFormat.format( &quot;The CRS for this srs_id is not exactly equivalent to the specification.  {0}&quot;,</span>
<span class="nc" id="L295">                            invalidSrsDefs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );                            		</span>
            	}
           
<span class="nc" id="L298">            }</span>
<span class="nc bnc" id="L299" title="All 16 branches missed.">        }</span>
<span class="nc" id="L300">    }</span>

    /**
     * NSG Req 19: Data validity SHALL be assessed against data value constraints specified in Table 26 below using a
     * test suite. Data validity MAY be enforced by SQL triggers.
     *
     * 19-A: Addresses Table 26 Rows 1-2 (regarding table &quot;gpkg_spatial_ref_sys&quot;)
     *
     * @throws SQLException
     *             if access to gpkg failed
     */
    @Test(groups = { &quot;NSG&quot; }, description = &quot;NSG Req 19-A (Data Validity: gpkg_spatial_ref_sys)&quot;)
    public void dataValidity_gpkg_spatial_ref_sys()
                            throws SQLException {
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if ( crsListing == null )</span>
<span class="nc" id="L315">            throw new SkipException( &quot;No designated CRS Lookup Table available&quot; );</span>

<span class="nc" id="L317">        String queryStr = &quot;SELECT srs_id,organization,description FROM gpkg_spatial_ref_sys;&quot;;</span>

<span class="nc" id="L319">        try (final Statement statement = this.databaseConnection.createStatement();</span>
<span class="nc" id="L320">                                final ResultSet resultSet = statement.executeQuery( queryStr )) {</span>
<span class="nc" id="L321">            final Collection&lt;String&gt; invalidOrgs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L322">            final Collection&lt;String&gt; invalidDesc = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">            while ( resultSet.next() ) {</span>
<span class="nc" id="L325">                String srsID = resultSet.getString( &quot;srs_id&quot; ).trim();</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">                if ( &quot;0&quot;.equals( srsID ) || &quot;-1&quot;.equals( srsID ) ) {</span>
<span class="nc" id="L327">                    continue;</span>
                }

                // --- test for: Table 26; Row 1
<span class="nc" id="L331">                String srsOrg = resultSet.getString( &quot;organization&quot; );</span>
<span class="nc" id="L332">                validateCrsOrganistion( srsID, srsOrg, invalidOrgs );</span>

                // --- test for: Table 26; Row 2
<span class="nc" id="L335">                String description = resultSet.getString( &quot;description&quot; );</span>
<span class="nc" id="L336">                validateCrsDescription( srsID, description, invalidDesc );</span>
<span class="nc" id="L337">            }</span>

<span class="nc" id="L339">            assertTrue( invalidOrgs.isEmpty(),</span>
<span class="nc" id="L340">                        MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid organization values for IDs: {0}, should be \'EPSG\' or \'NGA\'&quot;,</span>
<span class="nc" id="L341">                                              invalidOrgs.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc" id="L342">            assertTrue( invalidDesc.isEmpty(),</span>
<span class="nc" id="L343">                        MessageFormat.format( &quot;The gpkg_spatial_ref_sys table contains invalid descriptions for IDs: {0}&quot;,</span>
<span class="nc" id="L344">                                              invalidDesc.stream().map( Object::toString ).collect( Collectors.joining( &quot;, &quot; ) ) ) );</span>
<span class="nc bnc" id="L345" title="All 16 branches missed.">        }</span>
<span class="nc" id="L346">    }</span>

    private void validateCrsOrganistion( String srsID, String srsOrg, Collection&lt;String&gt; invalidOrgs ) {
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if ( srsOrg == null ) {</span>
<span class="nc" id="L350">            invalidOrgs.add( srsID + &quot;: null (expected 'EPSG' or 'NGA')&quot; );</span>
        } else {
<span class="nc" id="L352">            srsOrg = srsOrg.trim();</span>
<span class="nc bnc" id="L353" title="All 4 branches missed.">            if ( !&quot;EPSG&quot;.equalsIgnoreCase( srsOrg ) &amp;&amp; !&quot;NGA&quot;.equalsIgnoreCase( srsOrg ) ) {</span>
<span class="nc" id="L354">                invalidOrgs.add( srsID + &quot;: &quot; + srsOrg + &quot; (expected 'EPSG' or 'NGA')&quot; );</span>
            }
        }
<span class="nc" id="L357">    }</span>

    private void validateCrsDescription( String srsID, String description, Collection&lt;String&gt; invalidDesc ) {
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if ( description == null ) {</span>
<span class="nc" id="L361">            invalidDesc.add( srsID + &quot; (expected not to be null)&quot; );</span>
<span class="nc" id="L362">            return;</span>
        }
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if ( !isCrsDescriptionValid( description ) ) {</span>
<span class="nc" id="L365">            invalidDesc.add( srsID</span>
                             + &quot;: '&quot;
                             + description
                             + &quot;' (expected not to be an empty string, not all whitespace, not “unknown” (any case), not “tbd” (any case))&quot; );
<span class="nc" id="L369">            return;</span>
        }
<span class="nc" id="L371">        String expectedDescription = crsListing.getDescriptionBySrsId( srsID );</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">        if ( expectedDescription != null &amp;&amp; !isDescriptionAsExpected( description, expectedDescription ) ) {</span>
<span class="nc" id="L373">            invalidDesc.add( srsID + &quot; : '&quot; + description + &quot;' (expected: '&quot; + expectedDescription + &quot;')&quot; );</span>
        }
<span class="nc" id="L375">    }</span>

    private boolean isDescriptionAsExpected( String descriptionToTest, String expectedDescription ) {
<span class="nc" id="L378">        descriptionToTest = removeWhitespaces( descriptionToTest );</span>
<span class="nc" id="L379">        expectedDescription = removeWhitespaces( expectedDescription );</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if ( descriptionToTest.endsWith( &quot;.&quot; ) )</span>
<span class="nc" id="L381">            descriptionToTest = descriptionToTest.substring( 0, descriptionToTest.length() - 1 );</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if ( expectedDescription.endsWith( &quot;.&quot; ) )</span>
<span class="nc" id="L383">            expectedDescription = expectedDescription.substring( 0, expectedDescription.length() - 1 );</span>
<span class="nc" id="L384">        return descriptionToTest.equalsIgnoreCase( expectedDescription );</span>
    }

    private boolean compareDefintion( String definitionToTest, String expectedDefinition ) {
<span class="nc" id="L388">        definitionToTest = removeWhitespaces( definitionToTest );</span>
<span class="nc" id="L389">        expectedDefinition = removeWhitespaces( expectedDefinition );</span>
<span class="nc" id="L390">        return definitionToTest.equalsIgnoreCase( expectedDefinition );</span>
    }

    private List&lt;Object[]&gt; selectAnnexBySrsId( String srsID, List&lt;Object[]&gt; annexC_3395, List&lt;Object[]&gt; annexE_4326 ) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if ( srsID.equals( &quot;3395&quot; ) ) {</span>
<span class="nc" id="L395">            return annexC_3395;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">        } else if ( srsID.equals( &quot;4326&quot; ) ) {</span>
<span class="nc" id="L397">            return annexE_4326;</span>
<span class="nc bnc" id="L398" title="All 4 branches missed.">        } else if ( ( srsID.equals( &quot;5041&quot; ) ) || ( srsID.equals( &quot;5042&quot; ) ) ) {</span>
<span class="nc" id="L399">            return Collections.emptyList();</span>
        }
<span class="nc" id="L401">        return Collections.emptyList();</span>
    }

    private List&lt;Object[]&gt; populateAnnex( String annexTableName, String annexName ) {
<span class="nc" id="L405">        InputStream resourceToRead = this.getClass().getResourceAsStream( annexTableName );</span>
<span class="nc" id="L406">        try (BufferedReader br = new BufferedReader( new InputStreamReader( resourceToRead, &quot;UTF-8&quot; ) )) {</span>
<span class="nc" id="L407">            List&lt;Object[]&gt; annexEntries = new ArrayList&lt;&gt;();</span>
            String line;
<span class="nc bnc" id="L409" title="All 2 branches missed.">            while ( ( line = br.readLine() ) != null ) {</span>
<span class="nc" id="L410">                List&lt;String&gt; items = Arrays.asList( line.split( &quot;\\s*,\\s*&quot; ) );</span>
<span class="nc bnc" id="L411" title="All 4 branches missed.">                if ( !items.isEmpty() &amp;&amp; ( items.size() == 5 ) ) {</span>
<span class="nc" id="L412">                    addNewEntry( annexEntries, items.get( 0 ), items.get( 1 ), items.get( 2 ), items.get( 3 ),</span>
<span class="nc" id="L413">                                 items.get( 4 ) );</span>
                } else {
<span class="nc" id="L415">                    throw new SkipException( annexName + &quot; Table is corrupt &quot; );</span>
                }
<span class="nc" id="L417">            }</span>
<span class="nc" id="L418">            return annexEntries;</span>
<span class="nc bnc" id="L419" title="All 8 branches missed.">        } catch ( IOException e ) {</span>
<span class="nc" id="L420">            throw new SkipException( annexName + &quot; Table not available&quot; );</span>
        }
    }

    private void addNewEntry( List&lt;Object[]&gt; table, String zoom, String scale, String pixelSz, String matrixWidth,
                              String matrixHeight ) {
<span class="nc" id="L426">        int zoomAsInt = Integer.parseInt( zoom );</span>
<span class="nc" id="L427">        double scaleAsDouble = Double.parseDouble( scale );</span>
<span class="nc" id="L428">        double pixelSizeAsDouble = Double.parseDouble( pixelSz );</span>
<span class="nc" id="L429">        long matrixWidthAsLong = Long.parseLong( matrixWidth );</span>
<span class="nc" id="L430">        long matrixHeightAsLong = Long.parseLong( matrixHeight );</span>
<span class="nc" id="L431">        Object[] row = { zoomAsInt, scaleAsDouble, pixelSizeAsDouble, matrixWidthAsLong, matrixHeightAsLong };</span>
<span class="nc" id="L432">        table.add( row );</span>
<span class="nc" id="L433">    }</span>

    private String removeWhitespaces( String description ) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if ( description != null )</span>
<span class="nc" id="L437">            return description.trim().replaceAll( &quot;\\s+&quot;, &quot;&quot; );</span>
<span class="nc" id="L438">        return description;</span>
    }

    private boolean isCrsDescriptionValid( String srsDesc ) {
<span class="nc bnc" id="L442" title="All 6 branches missed.">        return srsDesc.length() &gt; 0 &amp;&amp; srsDesc.trim().length() &gt; 0 &amp;&amp; ( !srsDesc.equalsIgnoreCase( &quot;NULL&quot; ) )</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">               &amp;&amp; ( !srsDesc.equalsIgnoreCase( &quot;UNK&quot; ) ) &amp;&amp; ( !srsDesc.equalsIgnoreCase( &quot;UNKNOWN&quot; ) )</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">               &amp;&amp; ( !srsDesc.equalsIgnoreCase( &quot;TBD&quot; ) );</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>